[[security]]
= Security

[#104]
== {MUST} Secure Endpoints with OAuth 2.0

Every API endpoint needs to be secured using OAuth 2.0. Please refer to
the
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#security-definitions-object[official
OpenAPI spec] on how to specify security definitions in your API
specification or take a look at the following example.

[source,yaml]
----
components:
  securitySchemes:
    oauth2:
      type: oauth2
      flows:
        clientCredentials:
          tokenUrl: https://identity.zalando.com/oauth2/token
          scopes:
            fulfillment-order-service.read: Access right needed to read from the fulfillment order service.
            fulfillment-order-service.write: Access right needed to write to the fulfillment order service.
----

The example defines OAuth2 with client credentials flow as security standard
used for authentication when accessing endpoints. Additionally, there are two
API access rights (permissions) defined via the scopes section for later
endpoint authorization usage (see <<105, next section>>).

It makes little sense specifying the flow to retrieve OAuth tokens in the
`securitySchemes` section, as API endpoints should not care, how OAuth
tokens were created. Unfortunately the `flow` field is mandatory and cannot
be omitted. API endpoints should always set `flow: clientCredentials` and ignore
this information.

[#105]
== {MUST} Define and Assign Permissions (Scopes)

APIs must define permissions to protect their resources. Thus, at least one
permission must be assigned to each endpoint. Permissions are defined as shown
in the <<104, previous section>>. Please refer to <<225>> for designing permission
names.

APIs should stick to component specific permissions without resource extension
to avoid governance complexity of too many fine grained permissions. For the
majority of use cases, restricting access to specific API endpoints using read
and write is sufficient for controlling access for client types like merchant
or retailer business partners, customers or operational staff. However, in
some situations, where the API serves different types of resources for
different owners, resource specific scopes may make sense.

Some examples for standard and resource-specific permissions:

[cols="25%,20%,15%,40%",options="header",]
|=======================================================================
| Application ID | Resource ID | Access Type | Example
| `order-management` | `sales_order` | `read` | `order-management.sales_order.read`
| `order-management` | `shipment_order` | `read` | `order-management.shipment_order.read`
| `fulfillment-order` | | `write` | `fulfillment-order.write`
| `business-partner-service` | |`read` | `business-partner-service.read`
|=======================================================================

After permission names are defined and the permission is declared in the 
security definition at the top of an API specification, it should be assigned 
to each API operation by specifying a
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject[security
requirement] like this:

[source,yaml]
----
paths:
 /business-partners/{partner-id}:
    get:
      summary: Retrieves information about a business partner
      security:
        - oauth2:
          - business-partner.read
----

In very rare cases a whole API or some selected endpoints may not require
specific access control. However, to make this explicit you should assign the
`uid` pseudo permission in this case. It is the user id and always available
as OAuth2 default scope.

[source,yaml]
----
paths:
  /public-information:
    get:
      summary: Provides public information about ... 
               Accessible by any user; no permissions needed.
      security:
        - oauth2:
          - uid
----

Hint: you need not explicitly define the "Authorization" header; it is a
standard header so to say implicitly defined via the security section.


[#225]
== {MUST} Follow Naming Convention for Permissions

Permission names in APIs must conform to the following naming pattern:

[source,bnf]
-----
<permission> ::= <application>.<resource>.<action>

<application> ::= [a-z][a-z0-9-]*       -- application identifier
<resource>    ::= [a-z][a-z0-9-]*       -- resource identifier
<action>      ::= <standard-action> |   -- should be sufficient in most cases
                  <nonstandard-action>  -- for non-standard cases

<standard-action>    ::= read | create | update | delete  -- might be extended in the future
<nonstandard-action> ::= [a-z][a-z0-9-]*
-----

Standard actions should always be preferred. Nonstandard actions should be used
sparingly and only when the action doesn't fit semantics of any of the standard
ones.
